#!/usr/bin/env python3
"""
by nu11secur1ty 2025
make_request_and_url_opener.py

1) Paste a raw HTTP request (end with a single line containing only a dot: .)
2) Saves the pasted request to a text file (default: saved_request.txt)
3) Generates an opener script (default: open_request_url.py) that parses the saved
   request, builds the full URL (from absolute-target or Host + path), and opens it
   in the default browser.

Usage:
    python make_request_and_url_opener.py
    python make_request_and_url_opener.py saved_request.txt open_request_url.py
"""

from pathlib import Path
import sys
import os

def prompt_paste_request():
    print("Paste the raw HTTP request now. When finished, enter a single line with just a dot (.) to end paste.")
    lines = []
    while True:
        try:
            line = input()
        except EOFError:
            break
        if line.strip() == ".":
            break
        lines.append(line)
    return "\n".join(lines)

def write_file(path: Path, content: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8", newline="\n") as f:
        f.write(content)

def generate_opener(saved_txt_path: str, opener_path: str):
    """
    Generated opener script: reads saved_txt_path, parses first request line + Host header,
    builds a full URL and opens it in the default browser.
    """
    opener_code = f'''#!/usr/bin/env python3
"""
open_request_url.py - generated by make_request_and_url_opener.py

Reads: {saved_txt_path}
Parses the first request in the file and tries to build a full URL.
If the request-target is an absolute URL, uses it directly.
Otherwise uses Host header + request-target and default scheme (https by default),
or uses :scheme / X-Forwarded-Proto if present.

This script does NOT send the request; it only opens the constructed URL in the browser.
"""
import webbrowser
import pathlib
import re
import sys
import urllib.parse as _parse

TXT_PATH = {repr(saved_txt_path)}

def read_raw(path):
    p = pathlib.Path(path)
    if not p.exists():
        print("Saved request file not found:", path)
        sys.exit(1)
    return p.read_text(encoding="utf-8", errors="replace")

def parse_request(raw):
    # Normalize newlines
    raw = raw.replace('\\r\\n', '\\n').lstrip('\\n')
    lines = raw.split('\\n')
    if not lines:
        raise ValueError("Empty request")
    # find first non-empty request line
    i = 0
    while i < len(lines) and lines[i].strip() == "":
        i += 1
    if i >= len(lines):
        raise ValueError("No request line found")
    req_line = lines[i].strip()
    parts = re.split(r'\\s+', req_line, maxsplit=2)
    if len(parts) < 2:
        raise ValueError("Invalid request line: " + req_line)
    method = parts[0].upper()
    target = parts[1]
    # parse headers
    headers = {{}}
    i += 1
    while i < len(lines):
        ln = lines[i]
        i += 1
        if ln.strip() == "":
            break
        if ':' not in ln:
            continue
        name, val = ln.split(':', 1)
        headers[name.strip()] = val.lstrip()
    return method, target, headers

def build_full_url(method, target, headers):
    # if target is absolute URL -> use it
    t = target.strip()
    if t.lower().startswith("http://") or t.lower().startswith("https://"):
        return t
    # prefer explicit :scheme pseudo-header or X-Forwarded-Proto
    scheme = None
    if ':scheme' in headers:
        scheme = headers.get(':scheme')
    elif headers.get('X-Forwarded-Proto'):
        scheme = headers.get('X-Forwarded-Proto').split(',')[0].strip()
    # fallback: default to https unless user overrides later
    if not scheme:
        scheme = "https"
    host = headers.get('Host') or headers.get('host')
    if not host:
        raise ValueError("Host header not found; cannot build full URL from origin-form target")
    # ensure target starts with /
    if not t.startswith("/"):
        t = "/" + t
    return f"{{scheme}}://{{host}}{{t}}"

def main():
    raw = read_raw(TXT_PATH)
    try:
        method, target, headers = parse_request(raw)
    except Exception as e:
        print("Failed to parse saved request:", e)
        sys.exit(1)

    try:
        url = build_full_url(method, target, headers)
    except Exception as e:
        print("Couldn't auto-build URL:", e)
        # fallback: show user the request-target and ask for full URL
        print("\\nRequest target found:", target)
        user = input("Enter full URL to open (or press Enter to abort): ").strip()
        if not user:
            print("Aborted.")
            sys.exit(1)
        url = user

    print("Constructed URL:", url)
    # Ask user whether to open using default browser or change scheme/host
    choice = input("Open this URL in your browser? [Y/n] ").strip().lower()
    if choice in ('', 'y', 'yes'):
        print("Opening:", url)
        webbrowser.open(url)
        return
    else:
        alt = input("Enter alternate URL to open (or press Enter to abort): ").strip()
        if alt:
            print("Opening:", alt)
            webbrowser.open(alt)
        else:
            print("Aborted.")

if __name__ == '__main__':
    main()
'''
    write_file(Path(opener_path), opener_code)
    try:
        os.chmod(opener_path, 0o755)
    except Exception:
        pass

def main():
    default_txt = "saved_request.txt"
    default_opener = "open_request_url.py"

    saved_txt = sys.argv[1] if len(sys.argv) >= 2 else input(f"Enter filename to save the pasted request [{default_txt}]: ").strip() or default_txt
    opener_script = sys.argv[2] if len(sys.argv) >= 3 else input(f"Enter filename for the opener script [{default_opener}]: ").strip() or default_opener

    print()
    raw = prompt_paste_request()
    if raw.strip() == "":
        print("No content pasted. Exiting.")
        sys.exit(1)

    saved_path = Path(saved_txt)
    write_file(saved_path, raw)
    generate_opener(saved_txt, opener_script)

    print()
    print("Saved request to:", saved_path.resolve())
    print("Generated opener script:", Path(opener_script).resolve())
    print()
    print("Run the opener script to open the converted URL in your browser:")
    print(f"  python {opener_script}")
    print()
    print("Notes:")
    print("- If the request-line contains an absolute URL, that URL will be opened directly.")
    print("- Otherwise the script uses the Host header and the request-target to build the URL.")
    print("- Default scheme is HTTPS; the opener will use X-Forwarded-Proto or :scheme header if present.")
    print("- The opener does NOT send the request; it only opens the constructed URL in the browser.")

if __name__ == "__main__":
    main()
